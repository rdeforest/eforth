Table formatting like 'column -t'

  t = new Table [["a","b"], ["x","y"]]
  => Table { columns: [ {width: 1}, {width: 1} ], rows: [ [{v: "a"},...

  t.toString()
  => "a b\nx y"

  t.toList()
  => ["a b", "x y"]

# classes

## Column

Formatting and tracking a Column

    class Column
      constructor: (info) ->
        { @table
          @width = 0
          @c
          @name = Column.defaultName @c
        } = info

      cells: ->
        @table
          .cells[r]
          .map (r) -> r[@c]
          .filter (c) -> c

      resize: ->
        @width =
          @cells
            .map (c) -> c.width()
            .reduce Math.max

    Column.defaultName = (colNum) ->
      if colNum < 0
        throw new Error "Column index '#{colNum}' < 0"

      name = ""

      while colNum
        name = String.fromCharCode(mod = colNum % 26) + name
        colNum = (colNum - mod) / 26

      name


## Row

Formatting and tracking a Row

    class Row
      constructor: (info) ->
        {@table, @r} = info

      cells: -> @table.cells[@r]

## Cell

    dimensionDescriptor = (dim, value) ->
      value: value
      set: (d) ->
        this[dim].cellLeaving this
        this[dim] = d
        this[dim].cellEntering this

    class Cell
      constructor: (info) ->
        Object.defineProperties this,
          d = { v:
                  value: info.v
                  get: -> d.fn?(this) or d.v.value
                  set: (v) =>
                    if 'function' is typeof v
                      d.fn = v
                    else
                      d.v.value = v

                    @c.cellChanged this
                    @r.cellChanged this
                r: dimensionDescriptor 'r', info.r
                c: dimensionDescriptor 'c', info.c
                f: info.f
                t: info.t
                fn: info.fn
              }

      format: (f) ->
        if not f
          return @f or @c.format or @r.format or @t.format or Cell.format

        @c.cellChanging this, format: [@f, f]
        @f = f

      render: (targetMedium) -> @format.render targetMedium, @v

      toString: -> @render 'string'

      width: -> @toString().width

    Cell.format = (medium, value) ->
      value.toString()

## Table

    class Table
      constructor: (startData) ->
        @columns = []
        @rows = []

        if startData
          @init startData

      init: (data) ->
        notImplemented =
          new Error "Init from non-list-of-lists not yet implemented"

        if not Array.isArray data or
            isnt data.length (data.filter Array.isArray).length
          throw notImplemented

        if data.hasHeaders
          [headers, data...] = data
          @addColumn {name, c} for name, c in headers

        for rowData, r in data
          @addCells rowData.map (v, c) -> {v, r, c}

      addColumn: (info) ->
        info.t = this
        @columns[info.c] = new Column info

      updateColumn: (info) ->
        c = info.c

        col = @columns[c] or= new Column info

        col[k] = v for k, v of info
        col.resize()

      setCell: (info) ->
        info.table = this
        old = @cells[r][c]

        if old
          old[k] = v for k, v of info
        else
          cell = new Cell info
          @cells[r][c] = cell

      addCells: (cells) ->
        addCell cell for cell in cells

      toList: ->
        headers =
      toString: ->

