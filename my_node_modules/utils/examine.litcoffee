    ignore: ignore = ->
      setVar = (name, value) ->
        """
          return (function (v) {
            #{name} = v
          })
        """

      makeVar = (name, value) ->
        s =
          """
            var #{name};

          """

        if value isnt undefined
          s + setVar name, value
        else
          s

      asVars = (dict) ->
        newDict = {}

        for k, v of dict

          if 'function' is typeof v
            v = eval v.toString()

          eval makeVar k, dict[k]

          (eval "(v) -> #{k} = v") v

    module.exports = (opts) ->
      newElementsOf: (l) ->
        seen = 0

        loop
          yield l[seen..]
          seen = l.length

      announce: announce = (promise, description = "some promise") ->
        console.log "Started #{description}; will announce completion"
        summarize = (v) ->
          try
            JSON.stringify result, 0, 2
          catch e
            [ "Something like"
              result.toString().substr 0, 40
              "that couldn't be stringified because"
              e.message
            ].join " "

        promise
          .then (result) ->
            console.log "\n\n\n#{description} finished. Result was:\n",
                        summarize result

          .catch (error) ->
            console.log "\n\n\n#{description} failed. Error was:\n",
                        summarize error

      descriptor: descriptor = Object.getOwnPropertyDescriptor

      proto: proto = Object.getPrototypeOf

      ctor: ctor = (o) -> o.constructor

      props: props = (o) -> Object.getOwnPropertyNames(o).sort()

      syms: syms = Object.getOwnPropertySymbols

      merged: merged = (os...) -> Object.assign {}, os...

      pairsToDict: (pairs) ->
        Object.assign {},
          ((o = {})[k] = v for [k, v] in pairs)...

      descriptors: descriptors = (o) ->
        pairsToDict props(o).map (name) ->
          [name, descriptor o, name]

      definers: definers = (o) ->
        o while o = proto o

      parents: parents = (o) ->
        definers(o).map ctor

      allProps: allProps = (o) ->
        (props o).concat (props o for o in parents o)

      propDefiners: propDefiners = (o) ->
        for d in [o].concat definers o
          pd = {}
          pd[ctor(d).name] = props d

      globalNames: globalNames = (o) ->
        k for k in props global when global[k] is o

