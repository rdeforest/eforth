    ignore: ignore = ->
      setVar = (name, value) ->
        """
          return (function (v) {
            #{name} = v
          })
        """

      makeVar = (name, value) ->
        s =
          """
            var #{name};

          """

        if value isnt undefined
          s + setVar name, value
        else
          s

      asVars = (dict) ->
        newDict = {}

        for k, v of dict

          if 'function' is typeof v
            v = eval v.toString()

          eval makeVar k, dict[k]

          (eval "(v) -> #{k} = v") v

    module.exports = (opts) ->
      descriptor: descriptor = Object.getOwnPropertyDescriptor

      proto: proto = Object.getPrototypeOf

      ctor: ctor = (o) -> o.constructor

      props: props = (o) -> Object.getOwnPropertyNames(o).sort()

      syms: syms = Object.getOwnPropertySymbols

      merged: merged = (os...) -> Object.assign {}, os...

      pairsToDict: (pairs) ->
        Object.assign {},
          ((o = {})[k] = v for [k, v] in pairs)...

      descriptors: descriptors = (o) ->
        pairsToDict props(o).map (name) ->
          [name, descriptor o, name]

      definers: definers = (o) ->
        o while o = proto o

      parents: parents = (o) ->
        definers(o).map ctor

      allProps: allProps = (o) ->
        (props o).concat (props o for o in parents o)

      propDefiners: propDefiners = (o) ->
        for d in [o].concat definers o
          pd = {}
          pd[ctor(d).name] = props d

      globalNames: globalNames = (o) ->
        k for k in props global when global[k] is o

