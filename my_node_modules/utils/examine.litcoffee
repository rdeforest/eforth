    module.exports = (opts) ->
      newElementsOf: (l) ->
        fn =
          if 'function' is typeof l
            l
          else
            -> l

        l = fn()
        seen = 0

        loop
          l = fn()
          len = l.length
          yield l[seen..]
          seen = len

      announce: announce = (promise, description = "some promise") ->
        console.log "Started #{description}; will announce completion"
        summarize = (v) ->
          try
            JSON.stringify v, 0, 2
          catch e
            [ "Something like"
              v.toString().substr 0, 40
              "that couldn't be stringified because"
              e.message
            ].join " "

        promise
          .then (result) ->
            console.log "\n\n\n#{description} finished. Result was:\n",
                        summarize result

          .catch (error) ->
            console.log "\n\n\n#{description} failed. Error was:\n",
                        summarize error

      descriptor: descriptor = Object.getOwnPropertyDescriptor

      proto: proto = Object.getPrototypeOf

      ctor: ctor = (o) -> o.constructor

      props: props = (o) -> Object.getOwnPropertyNames(o).sort()

      syms: syms = Object.getOwnPropertySymbols

      merged: merged = (os...) -> Object.assign {}, os...

      pairsToDict: pairsToDict = (pairs) ->
        Object.assign {},
          ((o = {})[k] = v for [k, v] in pairs)...

      descriptors: descriptors = (o) ->
        pairsToDict (props(o).map (name) ->
          [name, descriptor o, name])...

      definers: definers = (o) ->
        o while o = proto o

      parents: parents = (o) ->
        definers(o).map ctor

      allProps: allProps = (o) ->
        (props o).concat (props o for o in parents o)

      propDefiners: propDefiners = (o) ->
        for d in [o].concat definers o
          pd = {}
          pd[ctor(d).name] = props d
          pd

      globalNames: globalNames = (o) ->
        k for k in props global when global[k] is o

