Follow-up thinking in the realm of the tree thing Bruce and I talk about a lot.

    memberTags = new Map

    class Tag
      constructor: (info = {}) ->
        { @name
          @desc
          members = [] } = info

        @members = new Set members

      toString: ->
        @constructor.name +
          (if @name then " (#{name})") +
          " " + JSON.stringify this

      addMember: (m) ->
        @members.add m

        memberTags.set m, tags = Tag.getTagsOf(m).add this

      removeMember: (m) ->
        @members.remove m

        allTags = Tag.getTagsOf m
        allTags.delete this

        if not allTags.size
          memberTags.delete allTags

      contains: (m, seen = new Set [this]) ->
        if @members.has m
          return true

        iter = @members.values()

        while not (subset = iter.next()).done
          subset = subset.value

          if not seen.has subset
            seen.add subset

            if  subset instanceof Tag and
                subset.contains m, seen
              return true

    Tag.getTagsOf = (member) ->
      memberTags.get(member) or new Set

    Tag.allTagsOf = (member) ->
      tags = Tag.getTagsOf member

      tags.forEach (tag) ->
        Tag.allTagsOf(tag).forEach (tag) -> tags.add tag

      tags

    Tag.forest = ->
      trees = {}

      memberTags.forEach (member, tag) ->
        if member instanceof Tag
          trees[member.name] = member.members()

          member.forEach (member)


Testing

    module.exports = (opts) -> {Tag}

    if false
      fooTag = new Tag name: 'foo'

      fooTag.addMember s = "a string"

      console.log fooTag

      barTag = new Tag name: 'bar'

      barTag.addMember fooTag

      console.log barTag

      console.log "true", barTag.contains s

      console.log "foo"
      Tag.getTagsOf(s).forEach (t) -> console.log t.name

      console.log "foo, bar"
      Tag.allTagsOf(s).forEach (t) -> console.log t.name
