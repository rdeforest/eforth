#                         *** WARNING ***
#
#             Combining this with yield() would probably have
#             unintended and unwanted consequences.
#
#                         *** WARNING ***

###

Usage:

    AsyncThrottle = require 'async-throttle'

    myAWS   = require 'aws-wrapper'

    myQueue = new AsyncThrottle 2 # up to two calls at a time

    myIAM   = myAWS(accountId).IAM

    myIAM 'listUsers'
      .then ({Users}) ->
        myCallTrackers =
          for u in Users
            myQueue.queue -> (new User u).init()

Or for brevity:

    q = myQueue.makeQueueFn()

    myIAM('listUsers').then ({Users}) ->
      myCallTrackers = q(-> (new User u).init()) for u in Users

###

class AsyncInvocation
  constructor: (@scheduler, @fn) ->
    @id       = @scheduler.nextCallId()

    @promise  = undefined
    @ended    = false
    @result   = undefined

    @scheduler.queued.push this
    @scheduler.maybeStartMore()

  start: ->
    # We use setImmediate() to force asynchronicity. The user shouldn't have to
    # know whether the function will return a 'then-able'.
    @taskInfo = setImmediate ->
      try

        # The Promise.resolve here is the other half of the previous comment
        # about the user not having to know what a call is going to do.
        (@promise = Promise.resolve @fn())
          .then  (r) => @return r
          .catch (e) => @throw  e

      catch e
        @barf e

  # YA NEVER KNOW
  cancel: -> clearImmediate @taskInfo

  _ended: (how, value) ->
    @ended = how
    @result = @[how] = value
    @scheduler.callDone this

  finished: (r) -> @_ended 'returned', r
  died:     (e) -> @_ended 'threw',    e
  barfed:   (e) -> @_ended 'barfed',   e

module.exports =
  class AsyncThrottle
    constructor: (@parallelism = 1) ->
      @taskId   = 0
      @queued   = []

      @started  = {}
      @returned = []
      @threw    = []
      @barfed   = []

    nextCallId:     -> @taskId()

    headroom:       -> @parallelism - @running().length

    running:        -> task for key, task of @started

    _bugTest: (msg, test) -> new Error "BUG: #{msg}" if test

    callDone: (call)->
      msg = switch
        when not call.ended                  then "but .ended is falsy"
        when not Array.isArray @[call.ended] then "but .ended is unrecognized"
        when call.ended is 'queued'          then "by queuing?! I don't think so"

      if e then throw new Error "BUG: call ended #{msg} "

      @started[call.id] = undefined
      @[call.ended].push call

    maybeStartMore: ->
      while @running().length < @parallelism and @queued.length
        call = @queued.unshift()
        @started[call.id] = call
        call.start()

    queueCall: (fn) ->
      if 'function' isnt typeof fn
        throw new Error 'Cannot queue a non-Function'

      @queued.push task = new AsyncInvocation this, fn

      task

    makeQueueFn: -> (fn) => @queueCall fn
