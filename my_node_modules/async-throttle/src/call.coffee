EventEmitter    = require 'events'

###

AsyncInvocation emits

  started
  returned - normal return
  threw    - error thrown from inside a Promise
  barfed   - error thrown from outside a Promise

###

module.exports =
  class AsyncInvocation extends EventEmitter
    constructor: (@id, @fn) ->
      @promise  = undefined
      @ended    = false
      @result   = undefined

      if 'function' isnt typeof @fn
        throw new Error "Second arg must be a function"

    start: ->
      # We use setImmediate() to force asynchronicity. The user shouldn't have
      # to call the API differently for sync and async calls.
      @taskInfo = setImmediate =>
        try

          # The Promise.resolve here is the other half of the previous comment
          # about the user not having to know what a call is going to do.
          (@promise = Promise.resolve @fn())
            .then  (r) => @_returned r
            .catch (e) => @_throw    e

        catch e
          @_barfed e

      @emit 'started'

    _returned: (r) -> @_ended 'returned' , r
    _threw:    (e) -> @_ended 'threw'    , e
    _barfed:   (e) -> @_ended 'barfed'   , e

    _ended: (how, value) ->
      @ended = how
      @result = @[how] = value
      @emit how, value

    # YA NEVER KNOW
    cancel: ->
      if @canceled
        @emit 'double cleared'
      else
        @canceled = true
        @_cancel()
        @emit 'cleared'

    _cancel: ->
      clearImmediate @taskInfo


