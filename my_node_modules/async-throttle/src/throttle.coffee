# AsyncThrottle emits 'queueEmpty' and 'queueFull'.
EventEmitter    = require 'events'

AsyncInvocation = require './call'

module.exports =
  class AsyncThrottle extends EventEmitter
    constructor: (opts = {}) ->
      { # Default parallelism of Infinity means the throttle is wide open.
        # To use this library a person must at least know they have to
        # override the defaults to get any throttling behavior at all.

        @parallelism = Infinity
      } = opts

      if not @parallelism
        throw new Error "Cannot have a falsy parallelism"

      @nextTaskId  = 0
      @queued      = []

      @started     = {}
      @returned    = []
      @threw       = []
      @barfed      = []

    headroom:        -> @parallelism - @running().length
    running:         -> (task for key, task of @started when typeof task?.ended isnt 'string')

    maybeStartMore:  ->
      while @running().length < @parallelism
        if not @queued.length
          return @emit 'queueEmpty'

        call = @queued.shift()
        @started[call.id] = call
        call.start()

    queueCall: (fn)  ->
      if 'function' isnt typeof fn
        throw new Error 'Cannot queue a non-Function'

      id = @nextTaskId++

      @queued.push (task = new AsyncInvocation id, fn)

      # Maybe do more with these later?
      task
        .on 'returned', -> @maybeStartMore()
        .on 'threw'   , -> @maybeStartMore()
        .on 'barfed'  , -> @maybeStartMore()

      if @running().length >= @parallelism
        return @emit 'queueFull'
      else
        @maybeStartMore()

      return task

    makeQueueFn: -> (fn) => @queueCall fn
