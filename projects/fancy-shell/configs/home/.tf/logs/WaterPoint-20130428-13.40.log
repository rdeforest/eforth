Waterpoint: pickled spitfires[326]

*** Connected ***
#$#mcp version: 2.1 to: 2.1
Cape Toad
A relatively smooth path along the coast.  The ocean rolls against the rocky coast.  One especially large, flat rock sits invitingly beside the path.  The afternoon sun shines brightly.  It is cool.  The coastal path leads north.
Last connected Sun Apr 28 13:31:51 2013 PDT from 63.224.54.239
#$#mcp-negotiate-can 440894672 package: mcp-negotiate min-version: 1.0 max-version: 2.0
#$#mcp-negotiate-can 440894672 package: mcp-cord min-version: 1.0 max-version: 1.0
#$#mcp-negotiate-can 440894672 package: dns-org-mud-moo-simpleedit min-version: 1.0 max-version: 1.0
#$#mcp-negotiate-can 440894672 package: dns-com-awns-ping min-version: 1.0 max-version: 1.0
#$#mcp-negotiate-can 440894672 package: dns-com-awns-widget min-version: 1.0 max-version: 1.0
#$#mcp-negotiate-can 440894672 package: dns-com-awns-eliza min-version: 1.0 max-version: 1.0
#$#mcp-negotiate-can 440894672 package: dns-com-turtleback-browse min-version: 1.0 max-version: 1.0
#$#mcp-negotiate-can 440894672 package: dns-com-awns-visual min-version: 1.0 max-version: 1.1
#$#mcp-negotiate-can 440894672 package: dns-com-ben-tfstatus min-version: 1.0 max-version: 1.0
#$#mcp-negotiate-can 440894672 package: dns-com-awns-buddy min-version: 1.0 max-version: 1.0
#$#mcp-negotiate-can 440894672 package: dns-com-awns-status min-version: 1.0 max-version: 1.0
#$#mcp-negotiate-can 440894672 package: dns-com-att-research-twin-window min-version: 1.0 max-version: 1.0
#$#mcp-negotiate-can 440894672 package: dns-com-nowhere-hello min-version: 0.1 max-version: 0.1
#$#mcp-negotiate-can 440894672 package: dns-com-awns-rehash min-version: 1.0 max-version: 1.0
#$#mcp-negotiate-can 440894672 package: dns-com-awns-ispell min-version: 1.0 max-version: 1.0
#$#mcp-negotiate-can 440894672 package: dns-com-awns-desktop min-version: 1.0 max-version: 1.0
#$#mcp-negotiate-can 440894672 package: dns-com-edumacation-im min-version: 1.0 max-version: 1.0
#$#mcp-negotiate-can 440894672 package: dns-com-edumacation-racko min-version: 1.0 max-version: 1.0
#$#mcp-negotiate-can 440894672 package: dns-com-awns-getset min-version: 1.0 max-version: 1.0
#$#mcp-negotiate-can 440894672 package: dns-com-awns-displayurl min-version: 1.0 max-version: 1.0
#$#mcp-negotiate-can 440894672 package: dns-com-edumacation-update min-version: 1.0 max-version: 1.0
#$#mcp-negotiate-can 440894672 package: dns-com-awns-jtext min-version: 1.0 max-version: 1.0
#$#mcp-negotiate-can 440894672 package: dns-com-edumacation-song min-version: 1.0 max-version: 1.0
#$#mcp-negotiate-can 440894672 package: dns-com-nop-sqmoo-objlist min-version: 1.0 max-version: 1.0
#$#mcp-negotiate-can 440894672 package: dns-com-nop-sqmoo-verblist min-version: 1.0 max-version: 1.0
#$#mcp-negotiate-can 440894672 package: dns-com-awns-serverinfo min-version: 1.0 max-version: 1.0
#$#mcp-negotiate-can 440894672 package: dns-com-awns-timezone min-version: 1.0 max-version: 1.0
#$#mcp-negotiate-can 440894672 package: dns-com-awns-googlewhack min-version: 1.0 max-version: 1.0
#$#mcp-negotiate-can 440894672 package: dns-com-fyigm-mypkg min-version: 1.5 max-version: 2.0
#$#mcp-negotiate-can 440894672 package: dns-com-nop-sqmoo-verbtext min-version: 1.0 max-version: 1.0
#$#mcp-negotiate-can 440894672 package: dns-com-fyigm-lex min-version: 1.0 max-version: 1.0
#$#mcp-negotiate-end 440894672
Name           Location                      Idle Time   Doing/Idle            
----           --------                      ---------   ----------            
craque         Moccasin Falls                73 days                           
Donovan        Moccasin Falls                11 days                           
Xythian        Tent                          10 days                           
Matthew        Coastal path                  9 days                            
Mordred        Moccasin Falls                8 days                            
Xplat          Coastal path                  5 days                            
James          Nature trail                  4 days                            
keith          Moccasin Falls                3 days      Even if I tried...    
Becky          Moccasin Falls                2 days                            
rgm            Inside the bookmobile         a day                             
Ford           Moccasin Falls                23 hours                          
Rachelle       Moccasin Falls                20 hours                          
Ben            Moccasin Falls                16 hours                          
Kenny          Moccasin Falls                16 hours    Conspiracy            
Ken            Moccasin Falls                13 hours                          
Charkes        Moccasin Falls                6 hours     Workin'               
pj             Moccasin Falls                5 hours                           
stucky         Moccasin Falls                4 hours                           
Roy            Moccasin Falls                4 hours                           
Chris          Moccasin Falls                3 hours                           
Marn           Moccasin Falls                2 hours                           
Eclipse        Moccasin Falls                an hour     bjort                 
Tobin          Dead man's reef               an hour                           
Rob            Moccasin Falls                an hour                           
Jim            Moccasin Falls                42 minutes                        
Lly            Moccasin Falls                33 minutes  sneezing              
Kyle           Moccasin Falls                21 minutes                        
Barry          Moccasin Falls                12 seconds                        
Crag           Cape Toad                     0 seconds                         

Total: 29 people, 2 of whom have been active recently.
@building-option +create-set-co
@create #993 named Generic Cardgame Instance:Generic Cardgame Instance,game
@prop _."feature" #2002 r
@prop _."rules" #-2 r
@prop _."hands" {} r
@prop _."piles" {} r
@prop _."state" E_PERM "" Type mismatch
@prop _."tasks" {} r
@prop _."user_error" 505926998 r
@prop _."game_error" 1537762733 r
@prop _."pending_notifications" E_PERM "" Type mismatch
@prop _."decks" {} r
@prop _."join_allowed" 1 r
@prop _."started" 0 r
@prop _."help_text" {} rc
@prop _."remind_task" 0 r
@prop _."last_remind" 0 r
@prop _."remind_interval" 30 rc
@prop _."observers" {} r
@prop _."ratings" {} rc
"_.("key") => E_PERM (Permission denied)
;_.("aliases") = {"Generic Cardgame Instance", "game"}
;_.("unique") = 1
;_.("offered") = #-1
;_.("object_size") = {40264, 1367049600}
;_.("review_marks") = {}
"_.("review_history") => E_PERM (Permission denied)

@verb _:"description" this none this
@program _:description
preamble = {this:dnamec(), @valid(this.rules) ? {tostr("Ruleset for this game:  ", this.rules:dname_and_number())} | {"The rules for this game are still nebulous."}, ""};
playerdesc = this.rules:game_player_description(this);
statedesc = (this.hands && this.started) ? this.rules:game_state_description(this, this:stateview(#-1)) | {};
for p in (this.contents)
  statedesc[$ + 1..$] = p:piledesc_to_strings(@p:cardview(#-1))[2..$];
endfor
if (this.join_allowed && (this != $code_utils:verb_loc()))
  joindesc = {"", this.started ? "(This game is in progress but is still open to new players.)" | tostr("(This game has not started yet.", (valid(this.rules) && (length(this.hands) >= this.rules:max_players(this))) ? "" | "  More players are probably welcome.", ")")};
else
  joindesc = {};
endif
return {@preamble, @playerdesc, @statedesc, @joindesc};
.

@verb _:"acceptable" this none this
@program _:acceptable
return $object_utils:isa(args[1], this.feature.generic_pile);
.

@verb _:"help_text" this none this
@program _:help_text
return {{$jtext.header, 1, this.name}, {$jtext.list, {$jtext.hgroup, "For help on the mechanics of playing this game, see help on ", this:help_text_link(this.feature), "."}, @valid(this.rules) ? {{$jtext.hgroup, "For help on the rules for this game, see help on ", this:help_text_link(this.rules), "."}} | {}, @this.decks ? {{$jtext.hgroup, "For help on naming cards in the ", (length(this.decks) == 1) ? "deck" | "various decks", ", see help on ", @$jtext:english_list($list_utils:map_arg(this, "help_text_link", this.decks)), "."}} | {}}, {$jtext.paragraph, "This is an instance of the generic card game.  These can be created by doing @create ", tostr(#2363.feature.generic_game), " named <whatever>, and then using GAME:set_rules(RULES) and GAME:set_deck(DECK[,INDEX]) to establish rules and whatever decks may be necessary."}, {$jtext.paragraph, valid(this.rules) ? tostr("For information on the programming interface for this game, do `about ", this.rules, "'.") | tostr("For information on the construction of rulesets, do `about <ruleset>'")}};
.

@verb _:"help_text_link" this none this
@program _:help_text_link
{object} = args;
return valid(object) ? {$jtext.link.root, {$jaddress.help, {{"subject", tostr(object)}}}, object:dname_and_number() + " "} | "**INVALID**";
.

@verb _:"getp" this none this
@program _:getp
{prop} = args;
if (caller != this.rules)
  raise(E_PERM);
endif
return this.(prop);
.

@verb _:"setp" this none this
@program _:setp
{prop, value} = args;
if (caller != this.rules)
  raise(E_PERM);
endif
return this.(prop) = value;
.

@verb _:"user_error" this none this
@program _:user_error
{msg} = args;
raise(this.user_error, msg);
.

@verb _:"game_error" this none this
@program _:game_error
{msg} = args;
raise(this.game_error, msg);
.

@verb _:"player_hand" this none this
@program _:player_hand
"return hand object corresponding to PLAYER in this game";
{plyr} = args;
for h in (this.hands)
  if (h.player == plyr)
    return h;
  endif
endfor
return #-1;
.

@verb _:"set_rules" this none this
@program _:set_rules
":set_rules(NEWRULES)";
"change the rules for this game to NEWRULES (must be a descendent of the generic ruleset).";
"Caller must be .rules, or game must not have started yet.";
{newrules} = args;
if (!(this.feature.generic_rules in $object_utils:ancestors(newrules)))
  raise(E_INVARG, "Not a valid rule set.");
elseif (this == this.feature.generic_game)
  raise(E_INVARG, "This is the generic.");
endif
try
  if (caller == this.rules)
    saverules = this.rules;
    this.rules = this.feature.generic_rules;
    if (this.started)
      this:user_error("Cannot change rules while game is in progress.");
    endif
  endif
  saverules = newrules;
finally
  this.rules = saverules;
endtry
.

@verb _:"set_deck" this none this
@program _:set_deck
":set_deck(NEWDECK[,INDEX])";
"NEWDECK will be the new [INDEXth] deck for this game (must be allowed by the current ruleset; if you want to change the rules, do that first).  Caller must be .rules, or game must not have started yet.  Consistency checking is done by :ensure_decks()";
{newdeck, ?index = 1} = args;
if (this == this.feature.generic_game)
  raise(E_INVARG, "This is the generic.");
endif
if (caller != this.rules)
  if (this.started)
    this:user_error("Cannot change decks while game is in progress.");
  endif
  if (!this.rules:allow_deck(newdeck, index))
    this:user_error(tostr(newdeck:name(), @(index > 1) ? {" (as deck #", index, ") "} | {}, " is not compatible with current rules."));
  endif
endif
if (length(this.decks) < index)
  "...temporarily fill in space with bogus decks";
  this.decks[(deckcount = $) + 1..index] = $list_utils:make(index - deckcount, #-2);
endif
this.decks[index] = newdeck;
.

@verb _:"ensure_decks" this none this
@program _:ensure_decks
":ensure_decks() makes sure all decks are specified and allowable.";
if (!valid(this.rules))
  this:user_error(tostr("What are the rules of this game?"));
endif
required = this.rules:deck_count();
deckcount = length(this.decks);
if (deckcount > required)
  this.decks[required + 1..$] = {};
  deckcount = required;
endif
missing = (deckcount != required) ? $list_utils:range(deckcount + 1, required) | {};
for i in [-deckcount..-1]
  if (!this.rules:allow_deck(this.decks[-i], -i))
    missing[1..0] = {-i};
  endif
endfor
if (!missing)
  "...yay..";
elseif (missing == {1})
  this:user_error("Need to specify a deck");
elseif (length(missing) == 1)
  this:user_error(tostr("Need to specify deck ", missing[1]));
else
  this:user_error(tostr("Need to specify decks ", $string_utils:english_list(missing)));
endif
.

@verb _:"handle_join" this none this
@program _:handle_join
":handle_join(plyr,options) add player to this game.  Unlike other actions this one must be issued by the game-instance itself, since the player identity (hand) doesn't exist beforehand.  This creates the new hand and then issues the JOIN action.";
{plyr, ?options = {}} = args;
if ((!(caller in {this, this.feature, plyr})) && (caller_perms() != plyr))
  raise(E_PERM);
endif
if (this:player_hand(plyr) != #-1)
  this:user_error("You are already in this game.");
endif
if (!(valid(this.rules) && this.join_allowed))
  this:user_error("You cannot join this game.");
endif
newh = $recycler:_create(this.feature.generic_hand);
$building_utils:set_names(newh, "hand");
this.hands[$ + 1..$] = {newh};
newh.game = this;
newh:join_initialize(plyr);
this.rules:handle_action_join(newh);
return newh;
.

@verb _:"handle_action" this none this
@program _:handle_action
":handle_action(WHO, WHAT, @PARAMS)";
" --- player/agent entry point for all actions.";
{who, what, @params} = args;
if (!(who in this.hands))
  "... who may be a totally random object";
  ok = what == "reset";
  if (ok)
    for h in (this.hands)
      if ($recycler:valid(h.player) && `connected_seconds(h.player) ! ANY')
        ok = 0;
        break;
      endif
    endfor
  endif
  if (!ok)
    this:user_error("You are not in this game.");
  endif
elseif (!((caller in {this.feature, this, this.rules, who.player, who, @who.agents}) || (caller_perms() == who.player)))
  "... caller cannot speak for WHO...";
  raise(E_PERM);
endif
if (what == "reset")
  this:reset();
  this:notify_reset(who);
else
  this.last_remind = time();
  if (this.tasks)
    this:resume_first();
    this:suspend_enqueue();
  endif
  this.rules:("handle_action_" + what)(who, @params);
endif
.

@verb _:"suspend_push" this none this
@program _:suspend_push
"how to suspend action-handling tasks";
this.tasks[1..0] = {task_id()};
return this:do_suspend(@args);
.

@verb _:"suspend_enqueue" this none this
@program _:suspend_enqueue
"how to suspend action-handling tasks";
this.tasks[$ + 1..$] = {task_id()};
return this:do_suspend(@args);
.

@verb _:"suspend_if_needed" this none this
@program _:suspend_if_needed
if ($command_utils:running_out_of_time())
  this:suspend_push(@args);
  return 1;
endif
return 0;
.

@verb _:"resume_first" this none this
@program _:resume_first
$code_utils:task_valid(task = this.tasks[1]) ? `resume(task) ! E_INVARG' | this:game_error("First task got killed.");
.

@verb _:"do_suspend" this none this
@program _:do_suspend
if (!(task_id() in this.tasks))
  this:game_error("called :do_suspend without pushing taskid");
endif
while (1)
  r = suspend(@args);
  i = task_id() in this.tasks;
  if (i == 1)
    this.tasks[1..1] = {};
    if (this.tasks)
      this:resume_first();
    endif
    return r;
  elseif (i == 0)
    this:game_error("You got kicked out of .tasks.");
  endif
  this:resume_first();
  args = {};
endwhile
.

@verb _:"queue_notify" this none this
@program _:queue_notify
"queue message about WHAT to WHOM with @PARAMS.";
"These should be used for announcements about state changes,";
"which should go out *after* announcements about actions.";
{what, whom, @params} = args;
if (caller != this.rules)
  raise(E_PERM);
endif
this.pending_notifications[$ + 1..$] = {args};
.

@verb _:"notify_move" this none this
@program _:notify_move
{who, cards, src, dest, ?past_tense = 0} = args;
if ((caller != this.rules) && (caller != this))
  raise(E_PERM);
endif
if ((dest.showing > 0) || (src.showing >= length(cards)))
  cardstr = " " + dest.deck:card_name_list(cards, " and ");
else
  cardstr = tostr(" ", length(cards), " card", (length(cards) == 1) ? "" | "s");
endif
prefix = {$pronoun_sub, "do", {"name", "player", {"dc"}}, " "};
fromlst = {};
if (src == who)
  if (dest in this.hands)
    vrb = past_tense ? "gave" | "gives";
    cardstr = cardstr + " to ";
    iobj = dest.player;
  else
    vrb = past_tense ? "played" | "plays";
    if (this.rules:get_state(dest, "plays_dest"))
      iobj = $nothing;
    else
      cardstr = cardstr + " on ";
      iobj = dest;
    endif
  endif
elseif (dest == who)
  vrb = past_tense ? "took" | "takes";
  if (this.rules:get_state(dest, "takes_dest"))
    iobj = $nothing;
  else
    cardstr = cardstr + " from ";
    iobj = src;
  endif
else
  vrb = past_tense ? "moved" | "moves";
  cardstr = cardstr + " from ";
  dobj = src;
  fromlst = {{"name", "dobj", {"d"}}, " to "};
  iobj = dest;
endif
if (!past_tense)
  vrb = {"verb", "player", vrb};
endif
msg = {@prefix, vrb, cardstr, @fromlst, @(iobj == $nothing) ? {} | {{"name", "iobj", {"d"}}}, "."};
this:say_to_watchers(msg, (who in this.hands) ? who.player | player);
this:do_agent_notify(verb, @args);
.

@verb _:"notify_bid" this none this
@program _:notify_bid
{who, bid} = args;
if ((caller != this.rules) && (caller != this))
  raise(E_PERM);
endif
msg = {$pronoun_sub, "do", {"name", "player", {"dc"}}, " ", {"verb", "player", "bids"}, " ", this.rules:bid_long_name(bid), "."};
this:say_to_watchers(msg, (who in this.hands) ? who.player | player);
this:do_agent_notify(verb, @args);
.

@verb _:"notify_concede" this none this
@program _:notify_concede
{who, concession} = args;
if ((caller != this.rules) && (caller != this))
  raise(E_PERM);
endif
msg = {$pronoun_sub, "do", {"name", "player", {"dc"}}, " ", {"verb", "player", "offers"}, " to concede", @`this.rules:concede_msg(this, who, concession)[3..$] ! E_VERBNF => {}', "."};
this:say_to_watchers(msg, (who in this.hands) ? who.player | player);
this:do_agent_notify(verb, @args);
.

@verb _:"notify_declare" this none this
@program _:notify_declare
{who, declaration} = args;
if ((caller != this.rules) && (caller != this))
  raise(E_PERM);
endif
msg = {$pronoun_sub, "do", {"name", "player", {"dc"}}, " ", {"verb", "player", "declares"}, " ", this.rules:declare_long_name(declaration), "."};
this:say_to_watchers(msg, (who in this.hands) ? who.player | player);
this:do_agent_notify(verb, @args);
.

@verb _:"notify_listeners notify_nwlisteners notify_watchers" this none this
@program _:notify_listeners
{msg, @rest} = args;
if ((caller != this.rules) && (caller != this))
  raise(E_PERM);
endif
group = this:(verb[8..$])();
if (typeof(msg) == STR)
  for dude in (group)
    dude:tell(msg);
  endfor
else
  this:say_to(group, msg, @rest);
endif
.

@verb _:"notify__kill" this none this
@program _:notify__kill
{who} = args;
if (caller != this.rules)
  raise(E_PERM);
endif
this:kill_hand(who);
.

@verb _:"reset" this none this
@program _:reset
if ((caller != this) && (caller != this.rules))
  raise(E_PERM);
endif
for t in (this.tasks)
  `kill_task(t) ! ANY';
endfor
this.tasks = {};
this.pending_notifications = {};
clear_property(this, "state");
clear_property(this, "join_allowed");
clear_property(this, "started");
this:stop_remind_task();
for p in (this.piles)
  $recycler:_recycle(p);
endfor
this.piles = {};
for h in (this.hands)
  if (!$recycler:valid(h.player))
    this:kill_hand(h);
    this.hands = setremove(this.hands, h);
  else
    h:reset();
  endif
endfor
.

@verb _:"kill_hand" this none this
@program _:kill_hand
":kill_hand(hand).  Completes a QUIT action by destroying HAND.";
{hand} = args;
if (!(caller in {this.rules, this}))
  raise(E_PERM);
endif
if (i = hand in this.hands)
  this.hands[i..i] = {};
elseif (hand in hand.game.hands)
  this:game_error("Hand belongs to a different game.");
endif
if (hand.prev_spam)
  this:("add_" + hand.prev_spam)(hand.player);
else
  this:remove_watcher(hand.player);
  this:remove_ignorer(hand.player);
endif
hand:do_agent_notify("notify_final");
$recycler:_recycle(hand);
.

@verb _:"init_piles" this none this
@program _:init_piles
{piles} = args;
"init_piles({{NAME,{PROP,VAL}...},...})";
if (caller != this.rules)
  raise(E_PERM);
endif
"kill bogus piles";
for p in (this.piles)
  if (!$recycler:valid(p))
    this.piles = setremove(this.piles, p);
  endif
endfor
"remove excess piles";
pcount = length(piles);
if (length(this.piles) > pcount)
  for p in (this.piles[pcount + 1..$])
    $recycler:_recycle(p);
  endfor
  this.piles[pcount + 1..$] = {};
endif
"create new piles as necessary";
for i in [length(this.piles) + 1..pcount]
  newp = $recycler:_create(this.feature.generic_pile);
  newp.game = this;
  this.piles[$ + 1..$] = {newp};
endfor
"initialize all piles";
this:moveto(player.location);
for i in [1..pcount]
  pile = this.piles[i];
  pile:reset();
  move(pile, this);
  $building_utils:set_names(pile, piles[i][1]);
  pile:game_initialize(@piles[i][2..$]);
  if (!$list_utils:assoc("nodrop", pile.options))
    pile:moveto(this.location);
  endif
endfor
.

@verb _:"joing*ame" this none none
@program _:joingame
if (caller != player)
  raise(E_PERM);
endif
if (!(this.feature in player:features()))
  player:tell("You may wish to @addfeature #2002 (cardgame feature)");
endif
this:try_join(player, {});
.

@verb _:"quitg*ame leaveg*ame start*game reset*game" this none none
@program _:quitgame
if (caller != player)
  raise(E_PERM);
endif
action = {"leave", "leave", "start", "reset"}[index("qlsr", verb[1])];
h = this:player_hand(player);
if ((h == #-1) && (action != "reset"))
  player:tell("You are not in this game.");
else
  this:try_action(h, action);
endif
.

@verb _:"@flush" this none none
@program _:@flush
if (caller != player)
  raise(E_PERM);
endif
who = this:player_hand(player);
this:handle_action(who, "reset");
for h in (this.hands)
  this:handle_action(h, "leave");
endfor
for p in (this.piles)
  if ($recycler:valid(p))
    $recycler:_recycle(p);
  endif
endfor
this.piles = {};
.

@verb _:"try_action try_join" this none this
@program _:try_action
"Call :handle_action/handle_join(@args) with suitable error wrapping.";
"This should only be used by command verbs.  Other verbs should invoke";
":handle_* directly and do their own wrapping as appropriate.";
"";
"Caller is expected to check that args[1] corresponds to `player'";
"  (args[1] == player for join, args[1].who == player for other stuff)";
"and be itself invoked so that `player' is reliable.";
if ((caller != this) && (caller != this.feature))
  raise(E_PERM);
endif
try
  this:("handle_" + verb[5..$])(@args);
except e (this.user_error)
  player:tell(e[2]);
except e (this.game_error)
  player:tell_lines({"An internal game error has been encountered:", "  " + e[2], "", "Traceback:"});
  player:tell_lines($code_utils:format_traceback(e[4]));
endtry
.

@verb _:"card_sub" this none this
@program _:card_sub
{msg, cardlist, deck} = args;
while (n = "%c" in msg)
  if (typeof(cardlist) == NUM)
    msg[n] = tostr(cardlist, " card", (cardlist == 1) ? "" | "s");
  elseif (strcmp("%C", msg[n]) == 0)
    msg[n] = deck:card_name_list(cardlist, " and ");
  else
    msg[n] = deck:short_name_list(cardlist, " and ");
  endif
endwhile
return msg;
.

@verb _:"push_fork" this none this
@program _:push_fork
{id} = args;
if (id in this.tasks)
  this:game_error("fork pushed twice?");
endif
this.tasks[1..0] = {id};
.

@verb _:"pop_fork" this none this
@program _:pop_fork
id = task_id();
if (!(i = id in this.tasks))
  this:game_error("fork not pushed?");
endif
if (i != 1)
  this:do_suspend();
else
  this.tasks[1..1] = {};
endif
.

@verb _:"stateview" this none this
@program _:stateview
"stateview(who) => list of {ATTRIB, VALUE}";
"this.state, as filtered to remove stuff you're not supposed to see";
{who} = args;
if ((who != #-1) && (!(caller in {who, @who.viewers})))
  raise(E_PERM);
endif
return this.started ? this.rules:game_stateview(this, who) | {};
.

@verb _:"start_remind_task" this none this
@program _:start_remind_task
if (caller != this.rules)
  raise(E_PERM);
endif
if (this.remind_task)
  `kill_task(this.remind_task) ! ANY';
endif
fork task (this.remind_interval)
  while (1)
    if (!this.started)
      this:stop_remind_task();
    endif
    if (this.remind_interval <= (elapsed = time() - this.last_remind))
      this.rules:issue_reminders(this);
      interval = this.remind_interval;
    else
      interval = this.remind_interval - elapsed;
    endif
    suspend(interval);
  endwhile
endfork
this.last_remind = time();
this.remind_task = task;
.

@verb _:"stop_remind_task" this none this
@program _:stop_remind_task
if (!(caller in {this, this.rules}))
  raise(E_PERM);
endif
task = this.remind_task;
clear_property(this, "remind_task");
clear_property(this, "last_remind");
"must be the last action in this verb,";
"since we may be killing ourselves...";
`kill_task(task) ! ANY';
.

@verb _:"do_agent_notify" this none this
@program _:do_agent_notify
{vb, @nargs} = args;
if (caller != this)
  raise(E_PERM);
endif
for h in (this.hands)
  h:do_agent_notify(vb, @nargs);
endfor
for o in (this.observers)
  `o:(vb)(#-1, @nargs) ! ANY';
endfor
.

@verb _:"debug" this none this
@program _:debug
{verb, @args} = args;
if (caller_perms() != this.owner)
  raise(E_PERM);
endif
return this:(verb)(@args);
.

@verb _:"nwlisteners" this none this
@program _:nwlisteners
"Usage:  :nwlisteners()";
"  The list of things listening but not watching.";
return $set_utils:diff(this:listeners(), this:watchers());
.

@verb _:"watchers" this none this
@program _:watchers
"Usage:  :watchers()";
"  The list of things nearby who are watching this.  Always includes all players.";
return $set_utils:union(this:players(), $set_utils:intersection(this:nearby(), this.watching));
.

@verb _:"players" this none this
@program _:players
ps = {};
for h in (this.hands)
  ps[1..0] = {h.player};
endfor
return ps;
.

@verb _:"add_observer" this none this
@program _:add_observer
{agent, ?options = {}} = args;
this.observers = setadd(this.observers, agent);
.

@verb _:"remove_observer" this none this
@program _:remove_observer
{agent} = args;
this.observers = setremove(this.observers, agent);
.

@verb _:"ignoring" this none this
@program _:ignoring
return this.ignoring;
.

@verb _:"do_pending_notifications" this none this
@program _:do_pending_notifications
if ((caller != this) && (caller != this.rules))
  raise(E_PERM);
endif
for n in (this.pending_notifications)
  {what, who, @params} = n;
  `this.rules:("notify_" + what)(who, @params) ! ANY';
endfor
this.pending_notifications = {};
.

@verb _:"notify_*" this none this
@program _:notify_
{who, @rest} = args;
if ((caller != this.rules) && (caller != this))
  raise(E_PERM);
endif
what = verb[8..$];
if (!`msg = this.rules.(what + "_msg") ! E_PROPNF')
  msg = {$pronoun_sub, "do", {"name", "player", {"dc"}}, " ", {"verb", "player", $english_utils:get_conj("/" + what)}, @(what == "pass") ? {} | {" ", {"name", "thing", {"d"}}}, "."};
endif
this:((what in {"join", "leave"}) ? "say_to_listeners" | "say_to_watchers")(msg, (who in this.hands) ? who.player | player);
this:do_agent_notify(verb, @args);
.

"***finished***
The Generic Cardgame Instance(#2363) has 7 kids.
Hearts game (#2485)   Dalmuti Game (#2300)   Lost Cities game (#2601)   Bridge Game (#2738)   6nimmt Game (#5571)   Solo Whist Game (#5236)   Skat Game (#7031)
generic spammy thing (#993) [ readable fertile ]
  Owned by Ragnar (#239).
  Child of generic thing (#5).
-------------------------------- finished ---------------------------------
generic spammy thing (#993) [ readable fertile ]
  Owned by Ragnar (#239).
  Child of generic thing (#5).
  #993:add_ignorer              Ragnar (#239)        rxd    this none this
  #993:remove_ignorer           Ragnar (#239)        rxd    this none this
  #993:add_watcher              Ragnar (#239)        rxd    this none this
  #993:remove_watcher           Ragnar (#239)        rxd    this none this
  #993:ignoring                 Ragnar (#239)        rxd    this none this
  #993:watchers                 Ragnar (#239)        rxd    this none this
  #993:listeners                Ragnar (#239)        rxd    this none this
  #993:nearby                   Ragnar (#239)        rxd    this none this
  #993:"say_to_listeners say_to_watchers say_to_nwlisteners" Ragnar (#239) rxd this none this
  #993:"tell_listeners tell_watchers tell_nwlisteners" Ragnar (#239) rxd this none this
  #993:"tell_lines_to_listeners tell_lines_to_watchers tell_lines_to_nwlisteners" Ragnar (#239) rxd this none this
  #993:ignore                   Ragnar (#239)        r d    this none none
  #993:watch                    Ragnar (#239)        r d    this none none
  #993:listen                   Ragnar (#239)        r d    none at/to this
  #993:say_to                   Ragnar (#239)        rxd    this none this
  #993:nwlisteners              Ragnar (#239)        rxd    this none this
-------------------------------- finished ---------------------------------
generic spammy thing (#993) [ readable fertile ]
  Owned by Ragnar (#239).
  Child of generic thing (#5).
.ignoring                Ragnar (#239)         r      {}
.watching                Ragnar (#239)         r      {}
-------------------------------- finished ---------------------------------
