// Generated by CoffeeScript 1.9.3
(function() {
  var Maze, Pin, warn,
    slice = [].slice;

  warn = function() {
    var warning;
    warning = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return console.log.apply(console, ["WARNING: "].concat(slice.call(warning)));
  };

  Pin = (function() {
    function Pin(name1, maze1) {
      this.name = name1;
      this.maze = maze1;
      this.shorts = {};
    }

    Pin.prototype.addShort = function(otherPin) {
      return this.shorts[otherPin.toString()] = true;
    };

    Pin.prototype.toString = function() {
      if (this.maze) {
        return this.maze + "." + this.name;
      } else {
        return this.name;
      }
    };

    Pin.prototype.connected = function(otherPin) {
      return this.shorts[otherPin.toString()];
    };

    return Pin;

  })();

  module.exports = {
    Maze: Maze = (function() {
      function Maze() {
        this.pins = this.outerPins = this.innerPins = this.paths = {};
      }

      Maze.prototype.canonical = function() {
        var canon, i, len, maze, name, pin, pins;
        pins = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        canon = [];
        for (i = 0, len = pins.length; i < len; i++) {
          pin = pins[i];
          switch (false) {
            case 'number' !== typeof pin:
              canon.push(this.addPin(pin, ''));
              break;
            case 'string' !== typeof pin:
              canon.push(this.addPin(pin, ''));
              break;
            case !pin.shorts:
              canon.push(pin);
              break;
            case !pin.length:
              canon.push(this.addPin.apply(this, pin));
              break;
            case 'object' !== typeof pin:
              for (maze in pin) {
                name = pin[maze];
                canon.push(this.addPin(name, maze));
              }
              break;
            default:
              warn("Could not canonize pin, ignored it: " + JSON.stringify(pin, null, 2));
          }
        }
        return canon;
      };

      Maze.prototype.addPin = function(pin, maze) {
        var existing, longName;
        pin = new Pin(pin, maze);
        longName = pin.toString();
        if (existing = this.pins[longName]) {
          return existing;
        }
        return this.pins[longName] = (maze ? this.innerPins : this.outerPins)[longName] = pin;
      };

      Maze.prototype.addWireOneWay = function(from, to) {
        var i, len, ref, short;
        from.addShort(to);
        ref = this.outerPins[to.name].shorts;
        for (i = 0, len = ref.length; i < len; i++) {
          short = ref[i];
          console.log(this.toString() + " -> " + short.toString());
          from.addShort(short);
        }
        return this;
      };

      Maze.prototype.addWire = function(from, to) {
        return this.addWireOneWay(from, to).addWireOneWay(to, from);
      };

      Maze.prototype.connect = function() {
        var from, i, len, pins, to;
        pins = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        pins = this.canonical.apply(this, pins);
        while (pins.length > 1) {
          from = pins.shift();
          for (i = 0, len = pins.length; i < len; i++) {
            to = pins[i];
            this.addWire(from, to);
          }
        }
        return this;
      };

      return Maze;

    })()
  };


  /*
  
  
  
  
  
  
       * External interface accepts list of pin names and submaze pin objects
      connect: (pins...) ->
        for pin, idx in pins
          if 'object' is typeof pin
            mazes = Object.keys pin
            if mazes.length > 1
              throw new Error "Missing braces? - #{pin}"
            maze = mazes[0]
            pins[idx] = @addPin maze, pin[maze]
          else
            pins[idx] = @addPin 'self', pin.toString()
  
        while pins.length > 1
          pin = pins.pop()
  
          for other in pins
            pin.connect other
            other.connect pin
  
        return this
  
      addPath: (path...) ->
        path = @canonical path
  
        [from, steps..., to] = path
  
        if from.connected to
          return this
  
        @testPath path...
  
        if path.length > 2
          console.log "Adding path: " + path
  
          (((@paths[from.maze] or=
            {})[from.name] or=
            {})[to.maze] or=
            {})[to.name] = steps
  
        this
  
      canonical: (path) ->
        realPath = []
  
        for step, idx in path
          if 'object' is typeof step
            if (subMazes = Object.keys step).length > 1
              throw new Error "Missing braces? #{path}"
  
            subMaze = subMazes[0]
            steps = @canonical (step[subMaze])...
  
            realPath.push new Path subMaze, steps...
          else
            realPath.push @addPin 'self', step
  
        realPath
  
      testPath: (from, to, more...) ->
        if known = @havePath from, to
          return known
  
        if not from
          throw new Error "testPath(false, ...)"
  
        if from.start
          if not @testPath from.steps...
            throw new Error "testPath(badPath, ...)"
  
        if not to
          return true
  
        if to.start
          if from.connected(maze: to.maze, name: to.start.name)
            return @testPath to, more...
          else
            throw new Error "#{from} not connected to submaze path #{to}?"
  
        if from.connected to
          return @testPath to, more...
  
        throw new Error "gap from #{from} to #{to}"
  
      havePath: (from, to) ->
        if not from
          throw new Error "havePath with false first arg?!"
  
        (( chk = @paths[from.maze]               ) and
         ( chk = chk[from.name or from.end.name] ) and
         ( chk = chk[to.maze]                    ) and
         ( chk = chk[to.name or to.start.name]   ))
   */

}).call(this);
