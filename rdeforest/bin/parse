#!/usr/bin/env coffee
# vim: ft=coffee

# Convert a journal to an object

{env, argv, stdin} = process = require 'process'

program = require 'commander'

(require '~/github/small-projects/utils').install()

program
  .version '0.0.0'
  .usage '[files...]'
  .option '-f, --format [format]', 'how to render the output'
  .option '-r, --repl', 'start CoffeeScript REPL with global.journal set to parsed files'
  .parse argv

normalizedArgs = (args) ->
  if not args.length
    return ['-']

  args.filter (first, i) ->
    i  is args.length - 1 or
    -1 is args[i + 1..].findIndex (other) -> other is first

fileNamesToStreams = (fileNames) ->
  Object.assign {},
    for fileName in fileNames when fileName isnt '-'
      "#{fileName}": fs.createReadStream fileName, encoding: 'utf-8'

main = ->
  gathered = {}
  args = normalizeArgs program.args
  streams = {}
  if '-' in args
    streams.stdin = stdin
  streams = Object.assign {}, fileNamesToStreams(args), streams

  Promise.all (
    for fileName, source of streams
      gather source
        .then (text) ->
          gathered[fileName] = text
  ) .then ->
      data = parse gathered

      output data, format if program.format

      if program.repl
        global.journal = data
        startRepl()

class Context
  @matcher: makeNamedRegexpMatcher /^(#+)\s*(.*)/,
                                  ["hashes", "context"]

  constructor: ({@hashes, @context}) ->

class Event
  @matcher: makeNamedRegexpMatcher /^\s*-\s*(\d\d?):(\d\d?)\s*:\s*(\w+)\s+(.*)/,
                                          ["hour", "minute", "verb", "details"]

  constructor: ({@hour, @minute, @verb, @details}) ->
    @addenda = []

class Addendum
  @matcher: makeNamedRegexpMatcher                       /^\s*:\s*(\w+)\s+(.*)/,
                                                            ["verb", "details"]

  constructor: ({@verb, @details}) ->

makeNamedRegexpMatcher = ({regexp, names}) ->
  (string) ->
    if matched = string.match regexp
      Object.assign {}, (
        for name, idx in names
          "#{name}": regexp[idx]
      )

coalesce = (items, item) ->
  if not items.length
    return [item]

  [earlierItems..., lastItem] = items

  if newLastItem = lastItem.amendedBy item
    earlierItems.concat newLastItem
  else
    items.concat item

parse = (namedTexts) ->
  parsers = Object.values parser.parsers
  namedData = Object.assign {}, namedTexts

  for source, text of namedData
    lines = textToLines text

    namedData[source] =
      lines
        .map (line) ->
          for itemTypeName, itemType of parse.parsers
            if info = itemType.matcher line
              return new itemType info
        .filter (item) -> item
        .reduce coalesce, []

parse.parsers = [Context, Event]

output = (data, format = 'colorized') ->
  if format not in Object.keys output
    console.error "Unknown format: '#{format}'"
    process.exit 1

  output[format] data

output.colorized = (data) ->

textToLines = (text) ->
  text.toString().split /(?:\n\r|\r\n|[\r\n])/g


main()
