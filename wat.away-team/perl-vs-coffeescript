# Perl

sub exampleErrorSink {
  my $error = $_{'error'};
  my $context = $_{'context'};
  my $abort = undef; # as falsy as possible

  # ...

  return $abort;
}

sub wrapperPhase {
  my ($phase, $args, $copiedArgs, $errorSink, $result) = @_;

  eval {
    return $wrapper->(@_);
  }; if ($errorSink) {
    eval {
      $abort = $errorSink->(error => \$@, $context => \@_);
    }; if ($abort) {
      die $abort;
    }
  }
}

# Returns something which should be a drop-in replacement for $fn but with
# side effect of calling $wrapper and possibly $errorSink if provided.
my $wrapCall = sub {
  my ($fn, $wrapper, $errorSink) = @_;

  return sub {
    my @copiedArgs = @_;
    my @results;

    my @wrapperArgs = (\@_, \@copiedArgs, $errorSink);

    wrapperPhase('before', @wrapperArgs);

    @results = $fn->(@copiedArgs);

    wrapperPhase('after', @wrapperArgs, \@results);

    return @results;
  };
}

# Example usage

sub callLogger {
  my ($fn, $tag, %opts) = @_;

  my $writer = $opts{'writer'} || sub { print STDERR @_ };

  my $logger = sub {
    my ($phase, $args, $copiedArgs, $errorSink, $result) = @_;

    $writer->("Phase: $phase, ...")
  }
  
  return wrapCall($fn, $logger);
}

sub exampleFn {
  my ($foo, $bar) = @_;

  return $foo + $bar; # It's just an example, shut up.
}

my $wrappedExample = callLogger(\&exampleFn, 'exampleFn');

__DATA__

###
# CoffeeScript

wrapCall = (wrapper, fn, errorSink) ->
  (args...) ->
    wrapper phase: 'before', args: args
    results = fn()
    wrapper phase: 'after', results: results
    return results

myLogger = (fn, tag, opts) ->
  writer = opts.writer or console.log

  logger = (fn, args, copiedArgs, ...) ->

# Or with events

class CallWrapper extends EventEmitter
  constructor: (@fn) ->
    @callCounter = 0

  call: (self, args) ->
    id = @callCounter++
    @emit 'willCall', self: self, args: args, callId: id

    try
      @inCall = true
      result = @fn.call @self, @args
    catch e
      @emit 'error', error: e, callId: id
    finally
      @inCall = false

    @emit 'callCompleted', self: self, args: args, callId: id

    return result
