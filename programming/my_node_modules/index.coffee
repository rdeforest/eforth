###

"making it all right"

A no holds barred library for making the V8 engine useful to me,
specifically.

Principles:

- One object, one job
- Favor composition over inhertiance
- Favor functional over object-oriented.
 - Evaluate lazily
 - Contain side-effects

- Meta operations defined on meta objects
 - instead of $.root.create details
 - use $.sys.create parent: $.root, details

- Separate inheritance/composition from namespace
 - $.meta.whatever isn't necessarily a child of $meta
 - 'global' namespace is how objects interact with their context
 - All objects constructed with a namespace

Objects:

- Root
 - What is common amongst all objects ever
 - child of null

###

define Root: {}

###

- HandlerMap
 - has
  - methods : Namespace<name : String, handlerId : Identifier>

- MessageDispatcher
 - has
  - HandlerMap handlers
  - PatternMap patterns

 - delegates
  - handlers
   - add/list/remove
  - patterns
   - add/list/match/remove

  - does
   - findHandler(messageName, args...) : 

  - listHandlers()                        : Map<handlerId, handler>

  - addMessagePattern(pattern, handlerId)
  - lookupMethod(messageName)             : found    MatchedMethod
  - define

- MatchedMethod
 - has
  - sender   : Root
  - receiver : Root
  - caller   : MessageDispatcher
  - definer  : MessageDispatcher

 - does send(messageName, args...)

###



###

- MetaClass
 - Scaffolding for the MOP
 - Parent to Class
 - child of Root
 - responsible for the "do this to that" mode of interaction

Discussion:

If .create is defined on Root, every object gains a .create method. No object
can ever have a 'create' member which means anything different from what is
defined on Root.

If .create is defined as "Object.create(parent, options) => child",

- Object becomes gate-keeper to create operations
- The global namespace is kept clean

###


###

- Class
 - Scaffolding for OP
 - child of Root

###


###

- Sys
 - Gateway to all things privilidged
 - child of Meta

###


###

- Function
 - child of Meta
 - does
  - apply/call
  - sig() : FunctionSignature

###


###

- Namespace
 - child of Meta
 - does
  - lookup(Path path) : Optional
 - has ...

- Optional
 - child of Meta
 - does
  - isPresent() : Boolean
  - apply(Function) : any

###


###

- Member
 - child of Root
 - Has namespace
 - Has name

###


###

- Method
 - child of Member

Other stuff

Verb usage

 - 'create'  instantiates  an entity
 - 'destroy' deconstructs  an entity

 - 'delete'  is never used

 - 'add'     associates    an entity with a set
 - 'remove'  disassociates an entity from a set

 - 'set'     associates    an entity with a key
 - 'get'     fetches       an entity its    key
 - 'unset'   disassociates an entity from a key

 - 'match'   groups the members of a collection by match quality
 - 'lookup'  is 

 - 'fetch'   has latency and resource cost

###


###

Questions:

- How do we reconcile functional and ColdMUD programming styles?
 - No side effects until task completes?

###

db = []
db.names = {}

class Optional
  constructor: (@_value) ->
    @_present = not not arguments.length and @_value isnt undefined
    @_value = Optional.value if @_value instanceof Optional

  present: -> @_present
  get: -> @_value

  apply: (fn) ->
    return @ unless @_present

    try
      new Optional fn @_value
    catch e
      new Optional

lookupId = (name) ->
  (new Optional name).apply (name) -> db.names[name]

lookup = (name) ->
  lookupId(name).apply (id) -> db[id]

create = (id, def = {}) ->
  { parent       = null
    classVars    = []
    instanceVars = []
    category     = null
  } = def

  db[id] = o = {} # ...
  o

redefine = -> throw new Error "Meaning of 'redefine' yet to be decided."

define = (nameAndDef) ->
  for name, def of nameAndDef
    if (id = lookupId name).present()
      redefine id, def
      continue

    db.names[name] = id = db.length
    db[id] = create def


